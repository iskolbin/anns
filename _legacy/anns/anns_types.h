#ifndef ANNS_TYPES_H_INCLUDED
#define ANNS_TYPES_H_INCLUDED


typedef double (*fbvp_t)   (double *x, double *u, double **u_x, double **u_xx, double ***u_xy, double *v, void *instance);
typedef double (*gbvp_t)   (double *x, double *u, double **u_x, double **u_xx, double ***u_xy, double u_a, double *u_ax, double *u_axx, double **u_axy, double *v, void *instance);
//typedef void   (*anns_func_t) (double *point, double *x, int t, int mixed_derivatives, void *ai);
typedef void   (*anns_func_t) (double *x, int c, int p, int t, int mixed_derivatives, void *anns_instance);
typedef double (*anns_func_eval_t) (double *z, double *y, int t, void *anns_instance);

typedef struct {
    fbvp_t A;    // Фукнция для вычисления функционала
    gbvp_t *A_g; // Функции для вычисления градиента функционала [сеть]
    int nvars;  // Число внешних переменных
    int m;     // Число контрольных точек (может менятся на m_)
    int m_;    // Число проверочных точек
    int mtmp;  // Число контрольных точек
    int *eval; // Вектор, определяющий порядок вычислений соответствующих сетей [сеть]
    int nt;    // Число сетей, участвующих в вычислении уравнения
    double delta; // Множитель
} anns_cond_t;



typedef struct {
    double *z;     // Вектор переменных сетей (указатель на текущую сеть (I) )
    double *zbest; // Вектор лучших сетей (указатель на текущую сеть (I) )
    double *zw;
    int nc;      // Текущее число нейронов в сети
    int nm;      // Максимальное число нейронов в сети (сколько выделенно памяти) (nc <= nm)
    int ncbest;  // Число нейронов в лучшей сохраненной сети
    int nctmp;   // Текущее число нейронов в сети (дубликат)
    int nsize;   // Размер нейрона
    int lenc;    // Текущее число переменных сети (nsize * nc)
    int lenm;    // Максимальное число переменных в сети (nsize * nm)
    int dim;     // Размерность пространства сети
    int T;       // Тип сети
    int I;       // Индекс сети в векторе z
    int *map;    // Используется когда размерность сети меньше размерности пространства и требуется сдвиг координат

    anns_func_eval_t ann_eval;
    anns_func_t *ann_val;       // Функции для вычисления ИНС в точке [сеть][степень производной]
    anns_func_t *ann_valgrad;   // Функции для вычисления ИНС и градиента переменных ИНС в точке [сеть][степень производной]
    anns_func_t *ann_val_wonly;
    anns_func_t *ann_valgrad_wonly;

    int zeroinsert; // Вставляемый нейрон заполняется нулями (иначе остается предыдущий)
} anns_net_t;



// Структура для вычислений
// Некоторые детали реализации, которые требуют улучшения:
// 1) Вычисления для смешанных производных проводятся в многомерных массивах, причем в нижне-диагональных,
// для экономии памяти. Это удобно для записи, возможно хорошо в плане производительности. Однако, при
// увеличении степени производной добавляется уровень косвенности, что, в конечном счёте, может стать
// проблемой. Иными словами, было бы разумно свести u_xy и u_axy к двумерному и трехмерному массиву и
// использовать арифметические смещения (тогда не будет необходимости увеличивать косвенность)
// UPD : вычисления уже проводятся не в нижнедиагональных, а обычных (это было сделано из-за того, что
// при вычислении градиента от центров требуется согласованность индексов, это накладные расходы, да и лень
// 2) В массиве векторов v хранятся предвычисленные переменные, которые будут передаваться в уравнение,
// в частности это требуется при разбиении на конечно-разностную сетку по времени, также можно применять для
// вычисленных значений источниковых компонентов
// 3) В массиве xm хранятся вычисленные на предыдущих итерациях наборы сетей - это, в частности требуется
// для гибридных алгоритмов
// 4) Стоит отметить, что вычисления для градиента совершенно не разумны в плане расхода памяти. Тут
// сохраняются все производные параметров для всех производных по пространству(при том, что нужны, по сути,
// только текущие для каждой переменной). Затраты памяти (dim+d-1)!/(dim-1)!d! без вычисления градиента, в
// текущей реализации это число умножается на число переменных (а должно увеличится незначительно). С другой
// стороны, уменьшаются накладные расходы от дополнительных вызовов функций. Плюс затраты памяти хоть и
// велики асимптотически, но из-за компактности представления не слишком велики.

typedef struct {
    int A;      // Общее число переменных
    int dim;    // Размерность пространства
    int nconds; // Число уравнений
    int nnets;  // Число сетей
    int nvars;  // Число внешних переменных
    int nmem;   // Число сохраняемых наборов сетей
    int nmax;   // Максимальное число нейронов в нейросетях

    double *w;      // Веса [нейрон]

    double **a;      // Предвычисленные обратные квадраты ширин (a = 1/b^2) [нейрон][пространство]
    double **b;      // Ширины [нейрон][пространство]
    double **xc;    // Предвычисленные разности координат и центров, умноженные на a(xc = a(x - x0) ) [нейрон][пространство]
    double *r;      // Предвычисленные растояния от центров, умноженные на a [нейрон]

    double ****phi;        // Вычисленные значения базисных функций [условие][точка][сеть][нейрон]
    double *****phi_x;     // Вычисленные значния 1-х производных по пространству базисных функций [условие][точка][сеть][нейрон][пространство]
    double ******phi_xx;   // Вычисленные значения 2-х производных по пространству базисных функций [условие][точка][сеть][нейрон][[пространство]]

    double **phi_b;      // Вычисленные значения производных по ширинам базисных функций [нейрон][пространство]
    double ***phi_bx;    // Вычисленные значения производных по пространству и ширинам базисных функций [нейрон][[пространство]]

    double ***q;       // Вычисленная сумма базисных функций [условие][точка][сеть]
    double ****q_x;    // Вычисленные суммы 1-х производных по пространству [условие][точка][сеть][пространство]
    double *****q_xx;  // Вычисленные суммы 1-х производных по пространству [условие][точка][сеть][[пространство]]

    double *u;      // Выход сети (u = p / q для НРБС и u = p для РБС) [сеть]
    double **u_x;   // Массив для вычисленных 1-х производных [сеть][пространство]
    double **u_xx;  // Массив для вычисленных несмешанных 2-х производных [сеть][пространство]
    double ***u_xy; // Массив для вычисленных смешанных частных производных 2-й степени [сеть][[пространство]]

    double **u_a;       // Производные выхода сети по параметрам сети [сеть][переменная сети]
    double ***u_ax;     // Массивы для вычисленных производных по параметрам сети производных по простанству 1-й степени [сеть][переменная сети][пространство]
    double ***u_axx;    // Массивы для вычисленных производных по параметрам сети несмешанных производных по простанству 2-й степени [сеть][переменная сети][пространство]
    double ****u_axy;   // Массивы для вычисленных производных по параметрам сети смешанных частных производных по простанству 2-й степени [сеть][переменная сети][[пространство]]

    int pointsselected;
    int netsselected;

    double ***v;  // Массив предвычисленных значений [уравнение][точка][индекс]
    double ****v_container;

    double *z;

    double **z_container;

    double ***v_;
    double ***vtmp;

    double ***points;  // Контрольные точки [уравнение][точка][пространство]
    double ***points_; // Проверочные точки [уравнение][точка][пространство]
    double ***pointstmp;
    double ****points_container;

    double **xm;    // Массив сохранённых наборов сетей [индекс]

    double *csum;

    double *g; // Массив для вычисления градиента
//    double **z;

    anns_cond_t **conds;
    anns_net_t  **nets;
} anns_cache_t;



typedef struct {
    int problemtag; // Ключ задачи (эллиптическая, параболичиская или гиперболическая)
    int typetag;    // Тип задачи (прямая, обратная)
    int index;      // Индекс задачи
    int subindex;   // Подиндекс задачи
    char *filename; // Сгенерированное имя файла

    int dim;    // Размерность пространства задачи
    int nconds; // Число уравнений
    int nnets;  // Число сетей
    int nmem;   // Число сохраняемых наборов сетей
    int A;      // Общее число переменных сетей
    int Aw;     // Общее число весов
    int M;      // Общее число контрольных точек
    int F;      // Тип функционала (квадратичный, абсолютный, линейный)
    int tdelta; // Тип инициализации поправочных коэффициентов (ручной, обратный по точкам уравнения, обратный по всем точкам)

    anns_cond_t **conds;
    anns_net_t  **nets;

    double *dpoint; // Вектор для свертки

    anns_cache_t *cache; // Вспомогательный контейнер для вычислений
    void *instance;      // Произвольная сущность, которая передаётся при вычислении функций ann_val и ann_valgrad

    double Jmax;  // Максимальное значение функционала в конкретной точке
    int cJmax;    // Индекс условия к которому относится точка с максимальным функционалом
    int pJmax;    // Индекс точки в которой функционал максимален

    double *z;     // Вектор сетей
    double *zw;
    double *zbest; // Вектор лучшего набора сетей
    double *ztmp;  // Ссылка на вектор сетей

    double t;
    double step; // Шаг конечно-разностного разбиения (для гибридных методов)
    int nsteps;  // Число шагов для конечно-разностного разбиения
    double start; // Начальное число для конечно-разностного разбиения

    void (*preeval) (double *z, void *anns_instance); // Функция вызывается перед вычислением функционала или градиента
} anns_instance_t;

#endif // ANNS_TYPES_H_INCLUDED
